"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("regenerator-runtime/runtime.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.map.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.regexp.constructor.js");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var path = require("path");

var os_1 = require("os");

var node_1 = require("vscode-languageserver/node");

var vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");

var vscode_uri_1 = require("vscode-uri");

var customMessages_1 = require("./shared/customMessages");

var settings_1 = require("./shared/settings");

var eslint_1 = require("./eslint");

var paths_1 = require("./paths");

var diff_1 = require("./diff");

var languageDefaults_1 = require("./languageDefaults"); // The connection to use. Code action requests get removed from the queue if
// canceled.


var connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all, {
  cancelUndispatched: function cancelUndispatched(message) {
    // Code actions can safely be cancel on request.
    if (node_1.Message.isRequest(message) && message.method === 'textDocument/codeAction') {
      var response = {
        jsonrpc: message.jsonrpc,
        id: message.id,
        result: null
      };
      return response;
    }

    return undefined;
  }
}); // Set when handling the initialize request.

var clientCapabilities;
var documents = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument); // The notebooks manager is using the normal document manager for the cell documents.
// So all validating will work out of the box since normal document events will fire.

var notebooks = new node_1.NotebookDocuments(documents);

function loadNodeModule(moduleName) {
  var r = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;

  try {
    return r(moduleName);
  } catch (err) {
    if (err.stack) {
      connection.console.error(err.stack.toString());
    }
  }

  return undefined;
} // Some plugins call exit which will terminate the server.
// To not loose the information we sent such a behavior
// to the client.


var nodeExit = process.exit;

process.exit = function (code) {
  var stack = new Error('stack');
  void connection.sendNotification(customMessages_1.ExitCalled.type, [code ? code : 0, stack.stack]);
  setTimeout(function () {
    nodeExit(code);
  }, 1000);
}; // Handling of uncaught exceptions hitting the event loop.


process.on('uncaughtException', function (error) {
  var message;

  if (error) {
    if (typeof error.stack === 'string') {
      message = error.stack;
    } else if (typeof error.message === 'string') {
      message = error.message;
    } else if (typeof error === 'string') {
      message = error;
    }

    if (message === undefined || message.length === 0) {
      try {
        message = JSON.stringify(error, undefined, 4);
      } catch (e) {// Should not happen.
      }
    }
  } // eslint-disable-next-line no-console


  console.error('Uncaught exception received.');

  if (message) {
    // eslint-disable-next-line no-console
    console.error(message);
  }
});
/**
 * Infers a file path for a given URI / TextDocument. If the document is a notebook
 * cell document it uses the file path from the notebook with a corresponding
 * extension (e.g. TypeScript -> ts)
 */

function inferFilePath(documentOrUri) {
  if (!documentOrUri) {
    return undefined;
  }

  var uri = (0, paths_1.getUri)(documentOrUri);

  if (uri.scheme === 'file') {
    return (0, paths_1.getFileSystemPath)(uri);
  }

  var notebookDocument = notebooks.findNotebookDocumentForCell(uri.toString());

  if (notebookDocument !== undefined) {
    var notebookUri = vscode_uri_1.URI.parse(notebookDocument.uri);

    if (notebookUri.scheme === 'file') {
      var filePath = (0, paths_1.getFileSystemPath)(uri);

      if (filePath !== undefined) {
        var textDocument = documents.get(uri.toString());

        if (textDocument !== undefined) {
          var extension = languageDefaults_1.default.getExtension(textDocument.languageId);

          if (extension !== undefined) {
            var extname = path.extname(filePath);

            if (extname.length === 0 && filePath[0] === '.') {
              return "".concat(filePath, ".").concat(extension);
            } else if (extname.length > 0 && extname !== extension) {
              return "".concat(filePath.substring(0, filePath.length - extname.length), ".").concat(extension);
            }
          }
        }
      }
    }
  }

  return undefined;
}

eslint_1.ESLint.initialize(connection, documents, inferFilePath, loadNodeModule);
eslint_1.SaveRuleConfigs.inferFilePath = inferFilePath;
var Request;

(function (Request) {
  function is(value) {
    var candidate = value;
    return candidate && candidate.token !== undefined && candidate.resolve !== undefined && candidate.reject !== undefined;
  }

  Request.is = is;
})(Request || (Request = {}));

var Thenable;

(function (Thenable) {
  function is(value) {
    var candidate = value;
    return candidate && typeof candidate.then === 'function';
  }

  Thenable.is = is;
})(Thenable || (Thenable = {}));

var BufferedMessageQueue = /*#__PURE__*/function () {
  function BufferedMessageQueue(connection) {
    _classCallCheck(this, BufferedMessageQueue);

    this.connection = connection;
    this.queue = [];
    this.requestHandlers = new Map();
    this.notificationHandlers = new Map();
  }

  _createClass(BufferedMessageQueue, [{
    key: "registerRequest",
    value: function registerRequest(type, handler, versionProvider) {
      var _this = this;

      this.connection.onRequest(type, function (params, token) {
        return new Promise(function (resolve, reject) {
          _this.queue.push({
            method: type.method,
            params: params,
            documentVersion: versionProvider ? versionProvider(params) : undefined,
            resolve: resolve,
            reject: reject,
            token: token
          });

          _this.trigger();
        });
      });
      this.requestHandlers.set(type.method, {
        handler: handler,
        versionProvider: versionProvider
      });
    }
  }, {
    key: "registerNotification",
    value: function registerNotification(type, handler, versionProvider) {
      var _this2 = this;

      connection.onNotification(type, function (params) {
        _this2.queue.push({
          method: type.method,
          params: params,
          documentVersion: versionProvider ? versionProvider(params) : undefined
        });

        _this2.trigger();
      });
      this.notificationHandlers.set(type.method, {
        handler: handler,
        versionProvider: versionProvider
      });
    }
  }, {
    key: "addNotificationMessage",
    value: function addNotificationMessage(type, params, version) {
      this.queue.push({
        method: type.method,
        params: params,
        documentVersion: version
      });
      this.trigger();
    }
  }, {
    key: "onNotification",
    value: function onNotification(type, handler, versionProvider) {
      this.notificationHandlers.set(type.method, {
        handler: handler,
        versionProvider: versionProvider
      });
    }
  }, {
    key: "trigger",
    value: function trigger() {
      var _this3 = this;

      if (this.timer || this.queue.length === 0) {
        return;
      }

      this.timer = setImmediate(function () {
        _this3.timer = undefined;

        _this3.processQueue();

        _this3.trigger();
      });
    }
  }, {
    key: "processQueue",
    value: function processQueue() {
      var message = this.queue.shift();

      if (!message) {
        return;
      }

      if (Request.is(message)) {
        var requestMessage = message;

        if (requestMessage.token.isCancellationRequested) {
          requestMessage.reject(new node_1.ResponseError(node_1.LSPErrorCodes.RequestCancelled, 'Request got cancelled'));
          return;
        }

        var elem = this.requestHandlers.get(requestMessage.method);

        if (elem === undefined) {
          throw new Error("No handler registered");
        }

        if (elem.versionProvider && requestMessage.documentVersion !== undefined && requestMessage.documentVersion !== elem.versionProvider(requestMessage.params)) {
          requestMessage.reject(new node_1.ResponseError(node_1.LSPErrorCodes.RequestCancelled, 'Request got cancelled'));
          return;
        }

        var result = elem.handler(requestMessage.params, requestMessage.token);

        if (Thenable.is(result)) {
          result.then(function (value) {
            requestMessage.resolve(value);
          }, function (error) {
            requestMessage.reject(error);
          });
        } else {
          requestMessage.resolve(result);
        }
      } else {
        var notificationMessage = message;

        var _elem = this.notificationHandlers.get(notificationMessage.method);

        if (_elem === undefined) {
          throw new Error("No handler registered");
        }

        if (_elem.versionProvider && notificationMessage.documentVersion !== undefined && notificationMessage.documentVersion !== _elem.versionProvider(notificationMessage.params)) {
          return;
        }

        _elem.handler(notificationMessage.params);
      }
    }
  }]);

  return BufferedMessageQueue;
}();

var ValidateNotification;

(function (ValidateNotification) {
  ValidateNotification.type = new node_1.NotificationType('eslint/validate');
})(ValidateNotification || (ValidateNotification = {}));

var messageQueue = new BufferedMessageQueue(connection);
messageQueue.onNotification(ValidateNotification.type, function (document) {
  void validateSingle(document, true);
}, function (document) {
  return document.version;
});
documents.onDidOpen( /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(event) {
    var document, settings;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            document = event.document;
            _context.next = 3;
            return eslint_1.ESLint.resolveSettings(document);

          case 3:
            settings = _context.sent;

            if (!(settings.validate !== settings_1.Validate.on || !eslint_1.TextDocumentSettings.hasLibrary(settings))) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return");

          case 6:
            if (settings.run === 'onSave') {
              messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);
            }

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}()); // A text document has changed. Validate the document according the run setting.

documents.onDidChangeContent( /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(event) {
    var document, uri, settings;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            document = event.document;
            uri = document.uri;
            eslint_1.CodeActions.remove(uri);
            _context2.next = 5;
            return eslint_1.ESLint.resolveSettings(document);

          case 5:
            settings = _context2.sent;

            if (!(settings.validate !== settings_1.Validate.on || settings.run !== 'onType')) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return");

          case 8:
            messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}()); // A text document has been saved. Validate the document according the run setting.

documents.onDidSave( /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(event) {
    var document, settings;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            document = event.document;
            _context3.next = 3;
            return eslint_1.ESLint.resolveSettings(document);

          case 3:
            settings = _context3.sent;

            if (!(settings.validate !== settings_1.Validate.on || settings.run !== 'onSave')) {
              _context3.next = 6;
              break;
            }

            return _context3.abrupt("return");

          case 6:
            messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());
documents.onDidClose( /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(event) {
    var document, settings, uri;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            document = event.document;
            _context4.next = 3;
            return eslint_1.ESLint.resolveSettings(document);

          case 3:
            settings = _context4.sent;
            uri = document.uri;
            eslint_1.ESLint.removeSettings(uri);
            eslint_1.SaveRuleConfigs.remove(uri);
            eslint_1.CodeActions.remove(uri);
            eslint_1.ESLint.unregisterAsFormatter(document);

            if (settings.validate === settings_1.Validate.on) {
              void connection.sendDiagnostics({
                uri: uri,
                diagnostics: []
              });
            }

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x4) {
    return _ref4.apply(this, arguments);
  };
}());

function environmentChanged() {
  eslint_1.ESLint.clearSettings();
  eslint_1.RuleSeverities.clear();
  eslint_1.SaveRuleConfigs.clear();
  eslint_1.ESLint.clearFormatters();

  var _iterator = _createForOfIteratorHelper(documents.all()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var document = _step.value;
      messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

var CommandIds;

(function (CommandIds) {
  CommandIds.applySingleFix = 'eslint.applySingleFix';
  CommandIds.applySuggestion = 'eslint.applySuggestion';
  CommandIds.applySameFixes = 'eslint.applySameFixes';
  CommandIds.applyAllFixes = 'eslint.applyAllFixes';
  CommandIds.applyDisableLine = 'eslint.applyDisableLine';
  CommandIds.applyDisableFile = 'eslint.applyDisableFile';
  CommandIds.openRuleDoc = 'eslint.openRuleDoc';
})(CommandIds || (CommandIds = {}));

connection.onInitialize(function (params, _cancel, progress) {
  var _clientCapabilities$t, _clientCapabilities$t2, _clientCapabilities$t3;

  progress.begin('Initializing ESLint Server');
  var syncKind = node_1.TextDocumentSyncKind.Incremental;
  clientCapabilities = params.capabilities;
  progress.done();
  var capabilities = {
    textDocumentSync: {
      openClose: true,
      change: syncKind,
      willSaveWaitUntil: false,
      save: {
        includeText: false
      }
    },
    workspace: {
      workspaceFolders: {
        supported: true
      }
    },
    executeCommandProvider: {
      commands: [CommandIds.applySingleFix, CommandIds.applySuggestion, CommandIds.applySameFixes, CommandIds.applyAllFixes, CommandIds.applyDisableLine, CommandIds.applyDisableFile, CommandIds.openRuleDoc]
    }
  };

  if (((_clientCapabilities$t = clientCapabilities.textDocument) === null || _clientCapabilities$t === void 0 ? void 0 : (_clientCapabilities$t2 = _clientCapabilities$t.codeAction) === null || _clientCapabilities$t2 === void 0 ? void 0 : (_clientCapabilities$t3 = _clientCapabilities$t2.codeActionLiteralSupport) === null || _clientCapabilities$t3 === void 0 ? void 0 : _clientCapabilities$t3.codeActionKind.valueSet) !== undefined) {
    capabilities.codeActionProvider = {
      codeActionKinds: [node_1.CodeActionKind.QuickFix, "".concat(node_1.CodeActionKind.SourceFixAll, ".eslint")]
    };
  }

  return {
    capabilities: capabilities
  };
});
connection.onInitialized(function () {
  var _clientCapabilities$w, _clientCapabilities$w2;

  if (((_clientCapabilities$w = clientCapabilities.workspace) === null || _clientCapabilities$w === void 0 ? void 0 : (_clientCapabilities$w2 = _clientCapabilities$w.didChangeConfiguration) === null || _clientCapabilities$w2 === void 0 ? void 0 : _clientCapabilities$w2.dynamicRegistration) === true) {
    void connection.client.register(node_1.DidChangeConfigurationNotification.type, undefined);
  }

  void connection.client.register(node_1.DidChangeWorkspaceFoldersNotification.type, undefined);
});
messageQueue.registerNotification(node_1.DidChangeConfigurationNotification.type, function (_params) {
  environmentChanged();
});
messageQueue.registerNotification(node_1.DidChangeWorkspaceFoldersNotification.type, function (_params) {
  environmentChanged();
});

function validateSingle(_x5) {
  return _validateSingle.apply(this, arguments);
}

function _validateSingle() {
  _validateSingle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(document) {
    var publishDiagnostics,
        settings,
        start,
        diagnostics,
        timeTaken,
        status,
        _iterator6,
        _step6,
        handler,
        _args9 = arguments;

    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            publishDiagnostics = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : true;

            if (documents.get(document.uri)) {
              _context9.next = 3;
              break;
            }

            return _context9.abrupt("return");

          case 3:
            _context9.next = 5;
            return eslint_1.ESLint.resolveSettings(document);

          case 5:
            settings = _context9.sent;

            if (!(settings.validate !== settings_1.Validate.on || !eslint_1.TextDocumentSettings.hasLibrary(settings))) {
              _context9.next = 8;
              break;
            }

            return _context9.abrupt("return");

          case 8:
            _context9.prev = 8;
            start = Date.now();
            _context9.next = 12;
            return eslint_1.ESLint.validate(document, settings);

          case 12:
            diagnostics = _context9.sent;

            if (publishDiagnostics) {
              void connection.sendDiagnostics({
                uri: document.uri,
                diagnostics: diagnostics
              });
            }

            timeTaken = Date.now() - start;
            void connection.sendNotification(customMessages_1.StatusNotification.type, {
              uri: document.uri,
              state: customMessages_1.Status.ok,
              validationTime: timeTaken
            });
            _context9.next = 47;
            break;

          case 18:
            _context9.prev = 18;
            _context9.t0 = _context9["catch"](8);
            // if an exception has occurred while validating clear all errors to ensure
            // we are not showing any stale once
            void connection.sendDiagnostics({
              uri: document.uri,
              diagnostics: []
            });

            if (settings.silent) {
              _context9.next = 45;
              break;
            }

            status = undefined;
            _iterator6 = _createForOfIteratorHelper(eslint_1.ESLint.ErrorHandlers.single);
            _context9.prev = 24;

            _iterator6.s();

          case 26:
            if ((_step6 = _iterator6.n()).done) {
              _context9.next = 33;
              break;
            }

            handler = _step6.value;
            status = handler(_context9.t0, document, settings.library);

            if (!status) {
              _context9.next = 31;
              break;
            }

            return _context9.abrupt("break", 33);

          case 31:
            _context9.next = 26;
            break;

          case 33:
            _context9.next = 38;
            break;

          case 35:
            _context9.prev = 35;
            _context9.t1 = _context9["catch"](24);

            _iterator6.e(_context9.t1);

          case 38:
            _context9.prev = 38;

            _iterator6.f();

            return _context9.finish(38);

          case 41:
            status = status || customMessages_1.Status.error;
            void connection.sendNotification(customMessages_1.StatusNotification.type, {
              uri: document.uri,
              state: status
            });
            _context9.next = 47;
            break;

          case 45:
            connection.console.info(eslint_1.ESLint.ErrorHandlers.getMessage(_context9.t0, document));
            void connection.sendNotification(customMessages_1.StatusNotification.type, {
              uri: document.uri,
              state: customMessages_1.Status.ok
            });

          case 47:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, null, [[8, 18], [24, 35, 38, 41]]);
  }));
  return _validateSingle.apply(this, arguments);
}

function validateMany(documents) {
  documents.forEach(function (document) {
    messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);
  });
}

messageQueue.registerNotification(node_1.DidChangeWatchedFilesNotification.type, /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(params) {
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            // A .eslintrc has change. No smartness here.
            // Simply revalidate all file.
            eslint_1.RuleMetaData.clear();
            eslint_1.ESLint.ErrorHandlers.clearNoConfigReported();
            eslint_1.ESLint.ErrorHandlers.clearMissingModuleReported();
            eslint_1.ESLint.clearSettings(); // config files can change plugins and parser.

            eslint_1.RuleSeverities.clear();
            eslint_1.SaveRuleConfigs.clear();
            _context6.next = 8;
            return Promise.all(params.changes.map( /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(change) {
                var fsPath, dirname, library, eslintClass;
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        fsPath = inferFilePath(change.uri);

                        if (!(fsPath === undefined || fsPath.length === 0 || (0, paths_1.isUNC)(fsPath))) {
                          _context5.next = 3;
                          break;
                        }

                        return _context5.abrupt("return");

                      case 3:
                        dirname = path.dirname(fsPath);

                        if (!dirname) {
                          _context5.next = 16;
                          break;
                        }

                        library = eslint_1.ESLint.ErrorHandlers.getConfigErrorReported(fsPath);

                        if (!(library !== undefined)) {
                          _context5.next = 16;
                          break;
                        }

                        eslintClass = eslint_1.ESLint.newClass(library, {}, false);
                        _context5.prev = 8;
                        _context5.next = 11;
                        return eslintClass.lintText('', {
                          filePath: path.join(dirname, '___test___.js')
                        });

                      case 11:
                        eslint_1.ESLint.ErrorHandlers.removeConfigErrorReported(fsPath);
                        _context5.next = 16;
                        break;

                      case 14:
                        _context5.prev = 14;
                        _context5.t0 = _context5["catch"](8);

                      case 16:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5, null, [[8, 14]]);
              }));

              return function (_x7) {
                return _ref6.apply(this, arguments);
              };
            }()));

          case 8:
            validateMany(documents.all());

          case 9:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function (_x6) {
    return _ref5.apply(this, arguments);
  };
}());

var CodeActionResult = /*#__PURE__*/function () {
  function CodeActionResult() {
    _classCallCheck(this, CodeActionResult);

    this._actions = new Map();
  }

  _createClass(CodeActionResult, [{
    key: "get",
    value: function get(ruleId) {
      var result = this._actions.get(ruleId);

      if (result === undefined) {
        result = {
          fixes: [],
          suggestions: []
        };

        this._actions.set(ruleId, result);
      }

      return result;
    }
  }, {
    key: "fixAll",
    get: function get() {
      if (this._fixAll === undefined) {
        this._fixAll = [];
      }

      return this._fixAll;
    }
  }, {
    key: "all",
    value: function all() {
      var result = [];

      var _iterator2 = _createForOfIteratorHelper(this._actions.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var actions = _step2.value;
          result.push.apply(result, _toConsumableArray(actions.fixes));
          result.push.apply(result, _toConsumableArray(actions.suggestions));

          if (actions.disable) {
            result.push(actions.disable);
          }

          if (actions.fixAll) {
            result.push(actions.fixAll);
          }

          if (actions.disableFile) {
            result.push(actions.disableFile);
          }

          if (actions.showDocumentation) {
            result.push(actions.showDocumentation);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (this._fixAll !== undefined) {
        result.push.apply(result, _toConsumableArray(this._fixAll));
      }

      return result;
    }
  }, {
    key: "length",
    get: function get() {
      var result = 0;

      var _iterator3 = _createForOfIteratorHelper(this._actions.values()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var actions = _step3.value;
          result += actions.fixes.length;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return result;
    }
  }]);

  return CodeActionResult;
}();

var Changes = /*#__PURE__*/function () {
  function Changes() {
    _classCallCheck(this, Changes);

    this.values = new Map();
    this.uri = undefined;
    this.version = undefined;
  }

  _createClass(Changes, [{
    key: "clear",
    value: function clear(textDocument) {
      if (textDocument === undefined) {
        this.uri = undefined;
        this.version = undefined;
      } else {
        this.uri = textDocument.uri;
        this.version = textDocument.version;
      }

      this.values.clear();
    }
  }, {
    key: "isUsable",
    value: function isUsable(uri, version) {
      return this.uri === uri && this.version === version;
    }
  }, {
    key: "set",
    value: function set(key, change) {
      this.values.set(key, change);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.values.get(key);
    }
  }]);

  return Changes;
}();

var CommandParams;

(function (CommandParams) {
  function create(textDocument, ruleId, sequence) {
    return {
      uri: textDocument.uri,
      version: textDocument.version,
      ruleId: ruleId,
      sequence: sequence
    };
  }

  CommandParams.create = create;

  function hasRuleId(value) {
    return value.ruleId !== undefined;
  }

  CommandParams.hasRuleId = hasRuleId;
})(CommandParams || (CommandParams = {}));

var changes = new Changes();
var ESLintSourceFixAll = "".concat(node_1.CodeActionKind.SourceFixAll, ".eslint");
messageQueue.registerRequest(node_1.CodeActionRequest.type, /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(params) {
    var result, uri, textDocument, createCodeAction, getDisableRuleEditInsertionIndex, escapeStringRegexp, createDisableLineTextEdit, createDisableSameLineTextEdit, createDisableFileTextEdit, getLastEdit, settings, problems, only, isSource, isSourceFixAll, textDocumentIdentifier, edits, fixes, documentVersion, allFixableRuleIds, kind, _iterator4, _step4, _loop, sameProblems, _iterator5, _step5, editInfo, same;

    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            getLastEdit = function _getLastEdit(array) {
              var length = array.length;

              if (length === 0) {
                return undefined;
              }

              return array[length - 1];
            };

            createDisableFileTextEdit = function _createDisableFileTex(textDocument, editInfo) {
              // If first line contains a shebang, insert on the next line instead.
              var shebang = textDocument.getText(node_1.Range.create(node_1.Position.create(0, 0), node_1.Position.create(0, 2)));
              var line = shebang === '#!' ? 1 : 0;
              var block = languageDefaults_1.default.getBlockComment(textDocument.languageId);
              return node_1.TextEdit.insert(node_1.Position.create(line, 0), "".concat(block[0], " eslint-disable ").concat(editInfo.ruleId, " ").concat(block[1]).concat(os_1.EOL));
            };

            createDisableSameLineTextEdit = function _createDisableSameLin(textDocument, editInfo) {
              var lineComment = languageDefaults_1.default.getLineComment(textDocument.languageId);
              var blockComment = languageDefaults_1.default.getBlockComment(textDocument.languageId);
              var currentLine = textDocument.getText(node_1.Range.create(node_1.Position.create(editInfo.line - 1, 0), node_1.Position.create(editInfo.line - 1, node_1.uinteger.MAX_VALUE)));
              var disableRuleContent;
              var insertionIndex; // Check if there's already a disabling comment. If so, we ignore the settings here
              // and use the comment style from that specific line.

              var matchedLineDisable = new RegExp("".concat(lineComment, " eslint-disable-line")).test(currentLine);
              var matchedBlockDisable = new RegExp("".concat(blockComment[0], " eslint-disable-line")).test(currentLine);

              if (matchedLineDisable) {
                disableRuleContent = ", ".concat(editInfo.ruleId);
                insertionIndex = getDisableRuleEditInsertionIndex(currentLine, lineComment);
              } else if (matchedBlockDisable) {
                disableRuleContent = ", ".concat(editInfo.ruleId);
                insertionIndex = getDisableRuleEditInsertionIndex(currentLine, blockComment);
              } else {
                // We're creating a new disabling comment.
                var commentStyle = settings.codeAction.disableRuleComment.commentStyle;
                disableRuleContent = commentStyle === 'line' ? " ".concat(lineComment, " eslint-disable-line ").concat(editInfo.ruleId) : " ".concat(blockComment[0], " eslint-disable-line ").concat(editInfo.ruleId, " ").concat(blockComment[1]);
                insertionIndex = node_1.uinteger.MAX_VALUE;
              }

              return node_1.TextEdit.insert(node_1.Position.create(editInfo.line - 1, insertionIndex), disableRuleContent);
            };

            createDisableLineTextEdit = function _createDisableLineTex(textDocument, editInfo, indentationText) {
              var lineComment = languageDefaults_1.default.getLineComment(textDocument.languageId);
              var blockComment = languageDefaults_1.default.getBlockComment(textDocument.languageId); // If the concerned line is not the first line of the file

              if (editInfo.line - 1 > 0) {
                // Check previous line if there is a eslint-disable-next-line comment already present.
                var prevLine = textDocument.getText(node_1.Range.create(node_1.Position.create(editInfo.line - 2, 0), node_1.Position.create(editInfo.line - 2, node_1.uinteger.MAX_VALUE))); // For consistency, we ignore the settings here and use the comment style from that
                // specific line.

                var matchedLineDisable = new RegExp("".concat(escapeStringRegexp(lineComment), " eslint-disable-next-line")).test(prevLine);

                if (matchedLineDisable) {
                  var insertionIndex = getDisableRuleEditInsertionIndex(prevLine, lineComment);
                  return node_1.TextEdit.insert(node_1.Position.create(editInfo.line - 2, insertionIndex), ", ".concat(editInfo.ruleId));
                }

                var matchedBlockDisable = new RegExp("".concat(escapeStringRegexp(blockComment[0]), " eslint-disable-next-line")).test(prevLine);

                if (matchedBlockDisable) {
                  var _insertionIndex = getDisableRuleEditInsertionIndex(prevLine, blockComment);

                  return node_1.TextEdit.insert(node_1.Position.create(editInfo.line - 2, _insertionIndex), ", ".concat(editInfo.ruleId));
                }
              } // We're creating a new disabling comment. Use the comment style given in settings.


              var commentStyle = settings.codeAction.disableRuleComment.commentStyle;
              var disableRuleContent;

              if (commentStyle === 'block') {
                disableRuleContent = "".concat(indentationText).concat(blockComment[0], " eslint-disable-next-line ").concat(editInfo.ruleId, " ").concat(blockComment[1]).concat(os_1.EOL);
              } else {
                // commentStyle === 'line'
                disableRuleContent = "".concat(indentationText).concat(lineComment, " eslint-disable-next-line ").concat(editInfo.ruleId).concat(os_1.EOL);
              }

              return node_1.TextEdit.insert(node_1.Position.create(editInfo.line - 1, 0), disableRuleContent);
            };

            escapeStringRegexp = function _escapeStringRegexp(value) {
              return value.replace(/[|{}\\()[\]^$+*?.]/g, '\\$&');
            };

            getDisableRuleEditInsertionIndex = function _getDisableRuleEditIn(line, commentTags) {
              var charIndex = line.indexOf('--');

              if (charIndex < 0) {
                if (typeof commentTags === 'string') {
                  return line.length;
                } else {
                  // commentTags is an array containing the block comment closing and opening tags
                  charIndex = line.indexOf(commentTags[1]);

                  while (charIndex > 0 && line[charIndex - 1] === ' ') {
                    charIndex--;
                  }
                }
              } else {
                while (charIndex > 1 && line[charIndex - 1] === ' ') {
                  charIndex--;
                }
              }

              return charIndex;
            };

            createCodeAction = function _createCodeAction(title, kind, commandId, arg, diagnostic) {
              var command = node_1.Command.create(title, commandId, arg);
              var action = node_1.CodeAction.create(title, command, kind);

              if (diagnostic !== undefined) {
                action.diagnostics = [diagnostic];
              }

              return action;
            };

            result = new CodeActionResult();
            uri = params.textDocument.uri;
            textDocument = documents.get(uri);

            if (!(textDocument === undefined)) {
              _context7.next = 13;
              break;
            }

            changes.clear(textDocument);
            return _context7.abrupt("return", result.all());

          case 13:
            _context7.next = 15;
            return eslint_1.ESLint.resolveSettings(textDocument);

          case 15:
            settings = _context7.sent;

            if (!(settings.validate !== settings_1.Validate.on || !eslint_1.TextDocumentSettings.hasLibrary(settings))) {
              _context7.next = 18;
              break;
            }

            return _context7.abrupt("return", result.all());

          case 18:
            problems = eslint_1.CodeActions.get(uri); // We validate on type and have no problems ==> nothing to fix.

            if (!(problems === undefined && settings.run === 'onType')) {
              _context7.next = 21;
              break;
            }

            return _context7.abrupt("return", result.all());

          case 21:
            only = params.context.only !== undefined && params.context.only.length > 0 ? params.context.only[0] : undefined;
            isSource = only === node_1.CodeActionKind.Source;
            isSourceFixAll = only === ESLintSourceFixAll || only === node_1.CodeActionKind.SourceFixAll;

            if (!(isSourceFixAll || isSource)) {
              _context7.next = 35;
              break;
            }

            if (!isSourceFixAll) {
              _context7.next = 33;
              break;
            }

            textDocumentIdentifier = {
              uri: textDocument.uri,
              version: textDocument.version
            };
            _context7.next = 29;
            return computeAllFixes(textDocumentIdentifier, AllFixesMode.onSave);

          case 29:
            edits = _context7.sent;

            if (edits !== undefined) {
              result.fixAll.push(node_1.CodeAction.create("Fix all fixable ESLint issues", {
                documentChanges: [node_1.TextDocumentEdit.create(textDocumentIdentifier, edits)]
              }, ESLintSourceFixAll));
            }

            _context7.next = 34;
            break;

          case 33:
            if (isSource) {
              result.fixAll.push(createCodeAction("Fix all fixable ESLint issues", node_1.CodeActionKind.Source, CommandIds.applyAllFixes, CommandParams.create(textDocument)));
            }

          case 34:
            return _context7.abrupt("return", result.all());

          case 35:
            if (!(problems === undefined)) {
              _context7.next = 37;
              break;
            }

            return _context7.abrupt("return", result.all());

          case 37:
            fixes = new eslint_1.Fixes(problems);

            if (!fixes.isEmpty()) {
              _context7.next = 40;
              break;
            }

            return _context7.abrupt("return", result.all());

          case 40:
            documentVersion = -1;
            allFixableRuleIds = [];
            kind = only !== null && only !== void 0 ? only : node_1.CodeActionKind.QuickFix;
            _iterator4 = _createForOfIteratorHelper(fixes.getScoped(params.context.diagnostics));

            try {
              _loop = function _loop() {
                var editInfo = _step4.value;
                documentVersion = editInfo.documentVersion;
                var ruleId = editInfo.ruleId;
                allFixableRuleIds.push(ruleId);

                if (eslint_1.Problem.isFixable(editInfo)) {
                  var workspaceChange = new node_1.WorkspaceChange();
                  workspaceChange.getTextEditChange({
                    uri: uri,
                    version: documentVersion
                  }).add(eslint_1.FixableProblem.createTextEdit(textDocument, editInfo));
                  changes.set("".concat(CommandIds.applySingleFix, ":").concat(ruleId), workspaceChange);
                  var action = createCodeAction(editInfo.label, kind, CommandIds.applySingleFix, CommandParams.create(textDocument, ruleId), editInfo.diagnostic);
                  action.isPreferred = true;
                  result.get(ruleId).fixes.push(action);
                }

                if (eslint_1.Problem.hasSuggestions(editInfo)) {
                  editInfo.suggestions.forEach(function (suggestion, suggestionSequence) {
                    var workspaceChange = new node_1.WorkspaceChange();
                    workspaceChange.getTextEditChange({
                      uri: uri,
                      version: documentVersion
                    }).add(eslint_1.SuggestionsProblem.createTextEdit(textDocument, suggestion));
                    changes.set("".concat(CommandIds.applySuggestion, ":").concat(ruleId, ":").concat(suggestionSequence), workspaceChange);
                    var action = createCodeAction("".concat(suggestion.desc, " (").concat(editInfo.ruleId, ")"), node_1.CodeActionKind.QuickFix, CommandIds.applySuggestion, CommandParams.create(textDocument, ruleId, suggestionSequence), editInfo.diagnostic);
                    result.get(ruleId).suggestions.push(action);
                  });
                }

                if (settings.codeAction.disableRuleComment.enable && ruleId !== eslint_1.RuleMetaData.unusedDisableDirectiveId) {
                  var _workspaceChange = new node_1.WorkspaceChange();

                  if (settings.codeAction.disableRuleComment.location === 'sameLine') {
                    _workspaceChange.getTextEditChange({
                      uri: uri,
                      version: documentVersion
                    }).add(createDisableSameLineTextEdit(textDocument, editInfo));
                  } else {
                    var lineText = textDocument.getText(node_1.Range.create(node_1.Position.create(editInfo.line - 1, 0), node_1.Position.create(editInfo.line - 1, node_1.uinteger.MAX_VALUE)));
                    var matches = /^([ \t]*)/.exec(lineText);
                    var indentationText = matches !== null && matches.length > 0 ? matches[1] : '';

                    _workspaceChange.getTextEditChange({
                      uri: uri,
                      version: documentVersion
                    }).add(createDisableLineTextEdit(textDocument, editInfo, indentationText));
                  }

                  changes.set("".concat(CommandIds.applyDisableLine, ":").concat(ruleId), _workspaceChange);
                  result.get(ruleId).disable = createCodeAction("Disable ".concat(ruleId, " for this line"), kind, CommandIds.applyDisableLine, CommandParams.create(textDocument, ruleId));

                  if (result.get(ruleId).disableFile === undefined) {
                    _workspaceChange = new node_1.WorkspaceChange();

                    _workspaceChange.getTextEditChange({
                      uri: uri,
                      version: documentVersion
                    }).add(createDisableFileTextEdit(textDocument, editInfo));

                    changes.set("".concat(CommandIds.applyDisableFile, ":").concat(ruleId), _workspaceChange);
                    result.get(ruleId).disableFile = createCodeAction("Disable ".concat(ruleId, " for the entire file"), kind, CommandIds.applyDisableFile, CommandParams.create(textDocument, ruleId));
                  }
                }

                if (settings.codeAction.showDocumentation.enable && result.get(ruleId).showDocumentation === undefined) {
                  if (eslint_1.RuleMetaData.hasRuleId(ruleId)) {
                    result.get(ruleId).showDocumentation = createCodeAction("Show documentation for ".concat(ruleId), kind, CommandIds.openRuleDoc, CommandParams.create(textDocument, ruleId));
                  }
                }
              };

              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }

            if (result.length > 0) {
              sameProblems = new Map(allFixableRuleIds.map(function (s) {
                return [s, []];
              }));
              _iterator5 = _createForOfIteratorHelper(fixes.getAllSorted());

              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  editInfo = _step5.value;

                  if (documentVersion === -1) {
                    documentVersion = editInfo.documentVersion;
                  }

                  if (sameProblems.has(editInfo.ruleId)) {
                    same = sameProblems.get(editInfo.ruleId);

                    if (!eslint_1.Fixes.overlaps(getLastEdit(same), editInfo)) {
                      same.push(editInfo);
                    }
                  }
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }

              sameProblems.forEach(function (same, ruleId) {
                if (same.length > 1) {
                  var sameFixes = new node_1.WorkspaceChange();
                  var sameTextChange = sameFixes.getTextEditChange({
                    uri: uri,
                    version: documentVersion
                  });
                  same.map(function (fix) {
                    return eslint_1.FixableProblem.createTextEdit(textDocument, fix);
                  }).forEach(function (edit) {
                    return sameTextChange.add(edit);
                  });
                  changes.set(CommandIds.applySameFixes, sameFixes);
                  result.get(ruleId).fixAll = createCodeAction("Fix all ".concat(ruleId, " problems"), kind, CommandIds.applySameFixes, CommandParams.create(textDocument));
                }
              });
              result.fixAll.push(createCodeAction("Fix all auto-fixable problems", kind, CommandIds.applyAllFixes, CommandParams.create(textDocument)));
            }

            return _context7.abrupt("return", result.all());

          case 47:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function (_x8) {
    return _ref7.apply(this, arguments);
  };
}(), function (params) {
  var document = documents.get(params.textDocument.uri);
  return document !== undefined ? document.version : undefined;
});
var AllFixesMode;

(function (AllFixesMode) {
  AllFixesMode["onSave"] = "onsave";
  AllFixesMode["format"] = "format";
  AllFixesMode["command"] = "command";
})(AllFixesMode || (AllFixesMode = {}));

function computeAllFixes(_x9, _x10) {
  return _computeAllFixes.apply(this, arguments);
}

function _computeAllFixes() {
  _computeAllFixes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(identifier, mode) {
    var uri, textDocument, settings, filePath, problems, originalContent, start, _result, saveConfig, offRules, onRules, overrideConfig, _iterator7, _step7, ruleId;

    return regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            uri = identifier.uri;
            textDocument = documents.get(uri);

            if (!(textDocument === undefined || identifier.version !== textDocument.version)) {
              _context11.next = 4;
              break;
            }

            return _context11.abrupt("return", undefined);

          case 4:
            _context11.next = 6;
            return eslint_1.ESLint.resolveSettings(textDocument);

          case 6:
            settings = _context11.sent;

            if (!(settings.validate !== settings_1.Validate.on || !eslint_1.TextDocumentSettings.hasLibrary(settings) || mode === AllFixesMode.format && !settings.format)) {
              _context11.next = 9;
              break;
            }

            return _context11.abrupt("return", []);

          case 9:
            filePath = inferFilePath(textDocument);
            problems = eslint_1.CodeActions.get(uri);
            originalContent = textDocument.getText();
            start = Date.now(); // Only use known fixes when running in onSave mode. See https://github.com/microsoft/vscode-eslint/issues/871
            // for details

            if (!(mode === AllFixesMode.onSave && settings.codeActionOnSave.mode === settings_1.CodeActionsOnSaveMode.problems)) {
              _context11.next = 19;
              break;
            }

            _result = problems !== undefined && problems.size > 0 ? new eslint_1.Fixes(problems).getApplicable().map(function (fix) {
              return eslint_1.FixableProblem.createTextEdit(textDocument, fix);
            }) : [];
            connection.tracer.log("Computing all fixes took: ".concat(Date.now() - start, " ms."));
            return _context11.abrupt("return", _result);

          case 19:
            if (!(filePath !== undefined && mode === AllFixesMode.onSave)) {
              _context11.next = 25;
              break;
            }

            _context11.next = 22;
            return eslint_1.SaveRuleConfigs.get(uri, settings);

          case 22:
            _context11.t0 = _context11.sent;
            _context11.next = 26;
            break;

          case 25:
            _context11.t0 = undefined;

          case 26:
            saveConfig = _context11.t0;
            offRules = saveConfig === null || saveConfig === void 0 ? void 0 : saveConfig.offRules;
            onRules = saveConfig === null || saveConfig === void 0 ? void 0 : saveConfig.onRules;

            if (offRules !== undefined) {
              overrideConfig = {
                rules: Object.create(null)
              };
              _iterator7 = _createForOfIteratorHelper(offRules);

              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  ruleId = _step7.value;
                  overrideConfig.rules[ruleId] = 'off';
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }

            return _context11.abrupt("return", eslint_1.ESLint.withClass( /*#__PURE__*/function () {
              var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(eslintClass) {
                var result, fixes, filtered, _iterator8, _step8, _step8$value, key, problem, content, reportResults, fixedContent, diffs, _iterator9, _step9, diff;

                return regeneratorRuntime.wrap(function _callee10$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        result = [];

                        if (problems !== undefined && problems.size > 0) {
                          // We have override rules that turn rules off. Filter the fixes for these rules.
                          if (offRules !== undefined) {
                            filtered = new Map();
                            _iterator8 = _createForOfIteratorHelper(problems);

                            try {
                              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                                _step8$value = _slicedToArray(_step8.value, 2), key = _step8$value[0], problem = _step8$value[1];

                                if (onRules !== null && onRules !== void 0 && onRules.has(problem.ruleId)) {
                                  filtered.set(key, problem);
                                }
                              }
                            } catch (err) {
                              _iterator8.e(err);
                            } finally {
                              _iterator8.f();
                            }

                            fixes = filtered.size > 0 ? new eslint_1.Fixes(filtered).getApplicable().map(function (fix) {
                              return eslint_1.FixableProblem.createTextEdit(textDocument, fix);
                            }) : undefined;
                          } else {
                            fixes = new eslint_1.Fixes(problems).getApplicable().map(function (fix) {
                              return eslint_1.FixableProblem.createTextEdit(textDocument, fix);
                            });
                          }
                        }

                        content = fixes !== undefined ? vscode_languageserver_textdocument_1.TextDocument.applyEdits(textDocument, fixes) : originalContent;
                        _context10.next = 5;
                        return eslintClass.lintText(content, {
                          filePath: filePath
                        });

                      case 5:
                        reportResults = _context10.sent;
                        connection.tracer.log("Computing all fixes took: ".concat(Date.now() - start, " ms."));

                        if (Array.isArray(reportResults) && reportResults.length === 1 && reportResults[0].output !== undefined) {
                          fixedContent = reportResults[0].output;
                          start = Date.now();
                          diffs = (0, diff_1.stringDiff)(originalContent, fixedContent, false);
                          connection.tracer.log("Computing minimal edits took: ".concat(Date.now() - start, " ms."));
                          _iterator9 = _createForOfIteratorHelper(diffs);

                          try {
                            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                              diff = _step9.value;
                              result.push({
                                range: {
                                  start: textDocument.positionAt(diff.originalStart),
                                  end: textDocument.positionAt(diff.originalStart + diff.originalLength)
                                },
                                newText: fixedContent.substr(diff.modifiedStart, diff.modifiedLength)
                              });
                            }
                          } catch (err) {
                            _iterator9.e(err);
                          } finally {
                            _iterator9.f();
                          }
                        } else if (fixes !== undefined) {
                          result.push.apply(result, _toConsumableArray(fixes));
                        }

                        return _context10.abrupt("return", result);

                      case 9:
                      case "end":
                        return _context10.stop();
                    }
                  }
                }, _callee10);
              }));

              return function (_x12) {
                return _ref9.apply(this, arguments);
              };
            }(), settings, overrideConfig !== undefined ? {
              fix: true,
              overrideConfig: overrideConfig
            } : {
              fix: true
            }));

          case 31:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _computeAllFixes.apply(this, arguments);
}

messageQueue.registerRequest(node_1.ExecuteCommandRequest.type, /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params) {
    var workspaceChange, commandParams, edits, textChange, url;
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            commandParams = params.arguments[0];

            if (!(params.command === CommandIds.applyAllFixes)) {
              _context8.next = 8;
              break;
            }

            _context8.next = 4;
            return computeAllFixes(commandParams, AllFixesMode.command);

          case 4:
            edits = _context8.sent;

            if (edits !== undefined) {
              workspaceChange = new node_1.WorkspaceChange();
              textChange = workspaceChange.getTextEditChange(commandParams);
              edits.forEach(function (edit) {
                return textChange.add(edit);
              });
            }

            _context8.next = 9;
            break;

          case 8:
            if ([CommandIds.applySingleFix, CommandIds.applyDisableLine, CommandIds.applyDisableFile].indexOf(params.command) !== -1) {
              workspaceChange = changes.get("".concat(params.command, ":").concat(commandParams.ruleId));
            } else if ([CommandIds.applySuggestion].indexOf(params.command) !== -1) {
              workspaceChange = changes.get("".concat(params.command, ":").concat(commandParams.ruleId, ":").concat(commandParams.sequence));
            } else if (params.command === CommandIds.openRuleDoc && CommandParams.hasRuleId(commandParams)) {
              url = eslint_1.RuleMetaData.getUrl(commandParams.ruleId);

              if (url) {
                void connection.sendRequest(customMessages_1.OpenESLintDocRequest.type, {
                  url: url
                });
              }
            } else {
              workspaceChange = changes.get(params.command);
            }

          case 9:
            if (!(workspaceChange === undefined)) {
              _context8.next = 11;
              break;
            }

            return _context8.abrupt("return", null);

          case 11:
            return _context8.abrupt("return", connection.workspace.applyEdit(workspaceChange.edit).then(function (response) {
              if (!response.applied) {
                connection.console.error("Failed to apply command: ".concat(params.command));
              }

              return null;
            }, function () {
              connection.console.error("Failed to apply command: ".concat(params.command));
              return null;
            }));

          case 12:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function (_x11) {
    return _ref8.apply(this, arguments);
  };
}(), function (params) {
  var commandParam = params.arguments[0];

  if (changes.isUsable(commandParam.uri, commandParam.version)) {
    return commandParam.version;
  } else {
    return undefined;
  }
});
messageQueue.registerRequest(node_1.DocumentFormattingRequest.type, function (params) {
  var textDocument = documents.get(params.textDocument.uri);

  if (textDocument === undefined) {
    return [];
  }

  return computeAllFixes({
    uri: textDocument.uri,
    version: textDocument.version
  }, AllFixesMode.format);
}, function (params) {
  var document = documents.get(params.textDocument.uri);
  return document !== undefined ? document.version : undefined;
});
documents.listen(connection);
notebooks.listen(connection);
connection.listen();
connection.console.info("ESLint server running in node ".concat(process.version));