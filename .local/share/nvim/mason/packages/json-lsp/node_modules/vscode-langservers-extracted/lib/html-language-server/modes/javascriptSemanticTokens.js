"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

require("regenerator-runtime/runtime.js");

var _marked = /*#__PURE__*/regeneratorRuntime.mark(getSemanticTokens);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSemanticTokens = exports.getSemanticTokenLegend = void 0;

function getSemanticTokenLegend() {
  if (tokenTypes.length !== 12
  /* TokenType._ */
  ) {
    console.warn('TokenType has added new entries.');
  }

  if (tokenModifiers.length !== 6
  /* TokenModifier._ */
  ) {
    console.warn('TokenModifier has added new entries.');
  }

  return {
    types: tokenTypes,
    modifiers: tokenModifiers
  };
}

exports.getSemanticTokenLegend = getSemanticTokenLegend;

function getSemanticTokens(jsLanguageService, document, fileName) {
  var _jsLanguageService$ge, spans, i, offset, length, tsClassification, tokenType, _tokenModifiers, startPos;

  return regeneratorRuntime.wrap(function getSemanticTokens$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _jsLanguageService$ge = jsLanguageService.getEncodedSemanticClassifications(fileName, {
            start: 0,
            length: document.getText().length
          }, '2020'), spans = _jsLanguageService$ge.spans;
          i = 0;

        case 2:
          if (!(i < spans.length)) {
            _context.next = 15;
            break;
          }

          offset = spans[i++];
          length = spans[i++];
          tsClassification = spans[i++];
          tokenType = getTokenTypeFromClassification(tsClassification);

          if (!(tokenType === undefined)) {
            _context.next = 9;
            break;
          }

          return _context.abrupt("continue", 13);

        case 9:
          _tokenModifiers = getTokenModifierFromClassification(tsClassification);
          startPos = document.positionAt(offset);
          _context.next = 13;
          return {
            start: startPos,
            length: length,
            typeIdx: tokenType,
            modifierSet: _tokenModifiers
          };

        case 13:
          _context.next = 2;
          break;

        case 15:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

exports.getSemanticTokens = getSemanticTokens;

function getTokenTypeFromClassification(tsClassification) {
  if (tsClassification > 255
  /* TokenEncodingConsts.modifierMask */
  ) {
    return (tsClassification >> 8
    /* TokenEncodingConsts.typeOffset */
    ) - 1;
  }

  return undefined;
}

function getTokenModifierFromClassification(tsClassification) {
  return tsClassification & 255
  /* TokenEncodingConsts.modifierMask */
  ;
}

var tokenTypes = [];
tokenTypes[0
/* TokenType.class */
] = 'class';
tokenTypes[1
/* TokenType.enum */
] = 'enum';
tokenTypes[2
/* TokenType.interface */
] = 'interface';
tokenTypes[3
/* TokenType.namespace */
] = 'namespace';
tokenTypes[4
/* TokenType.typeParameter */
] = 'typeParameter';
tokenTypes[5
/* TokenType.type */
] = 'type';
tokenTypes[6
/* TokenType.parameter */
] = 'parameter';
tokenTypes[7
/* TokenType.variable */
] = 'variable';
tokenTypes[8
/* TokenType.enumMember */
] = 'enumMember';
tokenTypes[9
/* TokenType.property */
] = 'property';
tokenTypes[10
/* TokenType.function */
] = 'function';
tokenTypes[11
/* TokenType.method */
] = 'method';
var tokenModifiers = [];
tokenModifiers[2
/* TokenModifier.async */
] = 'async';
tokenModifiers[0
/* TokenModifier.declaration */
] = 'declaration';
tokenModifiers[3
/* TokenModifier.readonly */
] = 'readonly';
tokenModifiers[1
/* TokenModifier.static */
] = 'static';
tokenModifiers[5
/* TokenModifier.local */
] = 'local';
tokenModifiers[4
/* TokenModifier.defaultLibrary */
] = 'defaultLibrary';